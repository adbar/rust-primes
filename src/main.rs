use std::collections::HashSet;
use std::env;
use std::process;
use std::time::Instant;

extern crate rayon;
//use rayon::prelude::*;


use plotters::prelude::*;

mod utils;

//const DOT_RADIUS: i32 = 1;


fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if config.output_type != "b-file" {
        utils::print_first_ones(config.start, config.number_type);
    }

    if config.output_type == "graph" {
        // optional dependencies

        let size = (config.stop as f64).sqrt() as isize;

        draw_graph("test1.png", size, config.start, utils::move_around, true)?;
        draw_graph("test2.png", size, config.start, utils::move_in_line, false)?;

    } else if config.output_type == "b-file" {

        let numbers = utils::compute_numbers_limit(config.start, config.number_type, config.stop);
        //let numbers = utils::compute_numbers_end(config.start, config.number_type, config.stop*10);

        //println!("# generated by ...");

        for (index, value) in (1..).zip(numbers.iter()) {
            println!("{} {}", index, value);
        }

    }

    Ok(())
}


struct Config<'a> {
    number_type: &'a str,
    start: usize,
    stop: usize,
    output_type: &'a str,
}


impl Config<'_> {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        let number_type = match args.get(1) {
            Some(arg) if utils::get_function(arg).is_some() || arg.contains("+") => arg,
            Some(_) => return Err("Invalid argument"),
            None => "primes",
        };

        let start = match args.get(2) {
            Some(arg) => match arg.parse::<usize>() {
                Ok(num) => num,
                Err(_) => return Err("Invalid argument"),
            },
            None => 1,
        };

        let stop = match args.get(3) {
            Some(arg) => match arg.parse::<usize>() {
                Ok(num) => num,
                Err(_) => return Err("Invalid argument"),
            },
            None => 1000000,
        };

        let valid_output = HashSet::from(["graph".to_string(), "b-file".to_string()]);

        let output_type = match args.get(4) {
            Some(arg) if valid_output.contains(arg) => arg,
            Some(_) => return Err("Invalid argument"),
            None => "b-file",
        };

        Ok(Config { number_type, start, stop, output_type })
    }
}


fn draw_graph<F>(
    filename: &str,
    size: isize,
    start: usize,
    movement_fn: F,
    adjust_coordinates: bool,
) -> Result<(), Box<dyn std::error::Error>>
where
    F: Fn(isize, usize) -> Vec<(isize, isize)>,
{
    let start_time = Instant::now();
    let maxnum = if adjust_coordinates { size / 2 } else { size };
    let mut coordinates = movement_fn(maxnum, start);

    println!("{} out of {}", coordinates.len(), size * size);

    let canvas_size: u32 = size as u32;

    let root = BitMapBackend::new(filename, (canvas_size, canvas_size)).into_drawing_area();
    root.fill(&WHITE)?;

    let recast_coordinates: Vec<(i32, i32)> = coordinates.iter_mut()
        .map(|(x, y)| {
            if adjust_coordinates {
                *x += maxnum;
                *y += maxnum;
            }
            (*x as i32, *y as i32)
        })
        .collect();

    for (x, y) in recast_coordinates {
        root.draw_pixel((x, y), &BLACK)?;
        //root.draw(&Circle::new(
        //    (x, y),
        //    DOT_RADIUS,
        //    ShapeStyle::from(&BLACK).filled(),
        //))?;
    }

    root.present()?;
    println!("Time taken: {:?}", start_time.elapsed());
    Ok(())
}

// https://numberspiral.com/
// https://t5k.org/
// https://en.wikipedia.org/wiki/Ulam_number

// grid instead of spiral


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_default_values() {
        let args = vec![];
        let config = Config::build(&args).unwrap();
        assert_eq!(config.number_type, "primes");
        assert_eq!(config.start, 1);
        assert_eq!(config.stop, 1000000);
        assert_eq!(config.output_type, "b-file");
    }

    #[test]
    fn test_config_valid_values() {
        let args = vec![
            String::from(""),
            String::from("primes+semiprimes"),
            String::from("1"),
            String::from("1000"),
            String::from("graph"),
        ];
        let config = Config::build(&args).unwrap();
        assert_eq!(config.number_type, "primes+semiprimes");
        assert_eq!(config.start, 1);
        assert_eq!(config.stop, 1000);
        assert_eq!(config.output_type, "graph");
    }

    #[test]
    fn test_config_error_values() {
        let args = vec![
            String::from(""),
            String::from("invalid"),
            String::from("10"),
            String::from("100"),
            String::from("graph"),
        ];
        assert!(Config::build(&args).is_err());

        let args = vec![
            String::from(""),
            String::from("primes"),
            String::from("invalid"),
            String::from("100"),
            String::from("graph"),
        ];
        assert!(Config::build(&args).is_err());

         let args = vec![
            String::from(""),
            String::from("primes"),
            String::from("10"),
            String::from("invalid"),
            String::from("graph"),
        ];
        assert!(Config::build(&args).is_err());

        let args = vec![
            String::from(""),
            String::from("primes"),
            String::from("10"),
            String::from("100"),
            String::from("invalid"),
        ];
        assert!(Config::build(&args).is_err());
    }
}
